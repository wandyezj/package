# Notes

Designed for TypeScript NPM libraries.

- build
- lint
- style
- test
- document
- publish

## Package Layout

- config
    - configuration files for tools
- doc
    - autogenerated public documentation for API exposed by the package
- documentation
    - mantually written internal documentation for development
- scripts
    - manually run scripts
- src
    - package source, should have a single `index.ts` file that exposes all public APIs.
- test
    - package tests

## Commands

### build

Standard development command.

### test

run tests

### test-coverage

get test coverage

separate command because test-coverage can take longer to run than simply running tests

### style

applys consistent formatting in src and test

### lint

detect common issues in src and test

### clean

remove contents of dist and temp

Wipe out the contents of dist and temp before building to avoid persistance of removed files.

### compile

Run the TypeScript compiler and generate the dist

### doc

Generates the doc folder

Uses compiled dist/index.d.ts

Checks for changes in the packages publish signature

### prepack

npm built in command automatically run before publish during `npm publish`

should be used to build everything and test the package.

## Standard Technologies

### Tools

- [Windows](https://www.microsoft.com/en-us/windows/)
- [Git](https://git-scm.com/)
- [GitHub](https://github.com/)
- [GitHub Desktop](https://desktop.github.com/)
- [GitHub CLI](https://cli.github.com/manual/gh_help_reference)
- [GitHub Actions](https://github.com/features/actions)
- [Visual Studio Code](https://code.visualstudio.com/)
- [npm](https://www.npmjs.com/)
- [node](https://nodejs.org/) [download node lts](https://nodejs.org/en/download/)
- [TypeScript](https://www.typescriptlang.org/)
- [jest](https://jestjs.io/)
- [prettier](https://prettier.io/)
- [eslint](https://eslint.org/)
- [api-extractor](https://api-extractor.com/)
    - api-documenter
    - api-extractor-run
    - api-documenter-run
- [ts-node](https://github.com/TypeStrong/ts-node)

note: the template will need to be updated as technology changes.

### Libraries

Libraries for solving common problems

- [jsonc-parser](https://www.npmjs.com/package/jsonc-parser)
    - parse JSON with comments using `stripComments`

- [JSDOM](https://www.npmjs.com/package/jsdom)
    - parse html in node

- [terser](https://terser.org/)
    - JavaScript minifier

### Visual Studio Code Extensions

- ESLint
    - config: `config\eslint.json`
    - requires command line option `--config`
    - requires .vscode\settings.json `"eslint.options": { "configFile": "config/eslint.json", "resolvePluginsRelativeTo": "${workspaceFolder}" },`
- Prettier
    - config: `config\prettier.json`
    - requires command line option `--config`
    - requires .vscode\settings.json `"prettier.configPath": "config/prettier.json",`
- markdownlint
    - config: `config\.markdownlint.json`
    - requires .vscode\settings.json `"markdownlint.config": { "extends": "./config/.markdownlint.json" },`

## Technology and Design Considerations

Technologies were chosen based on ubiquity and commitment to long term support.

Widely deployed technologies with long term support are more likely to remain stable platforms in the future.

Adopting every new technology that has some small benefit comes with a cost. It's preferable to pick good standards that will remain relevant into the future to enable developers to focus on building new things instead of selecting and configuring tools. Standard widely adopted and well supported technologies are more likely to: have good support for common scenarios, have significant documentation, work together, and evolve together.

- Strong types, Strong contracts, implicitly difficult in a dynamically typed language
- Minimize Dependencies, document any reasons for dependencies, why they are required and how they are used
- Reduce Attack Surface Area, everyone is responsible to security, do not invent or implement custom hashing or cryptographic algorithms leave these things to experts, do not use duplicate tools when one will do, this increases the attack surface are unnecessarily.
- Privacy, do not send any data, do not cache or store any data
- Semantic Versioning, avoid unless practicing it strictly, every change is a potential breaking change, perhaps even unexpectedly, semantic versioning is a way to signal, but it needs to adhere to a specified contract about what is considered breaking, but it is still inaccurate in terms of how dependencies are taken, execution changes verses compilation changes

Move all possible configs under the config folder:

- have clarity where configs exist
- have clarity on what calls the configs
- remove clutter in the root folder

## Features

- Visual Studio Code F5 Debugging for jest tests.

## Node Version

This package is intended to work on the laster node version and included NPM version.

## NPM Version Issues

`npm@7.5.4` does not allow script execution with unit style paths as in the package.json instead revert to an older version of npm that allows this behavior `npm install -g npm@6.14.9`

The above shows the importance of versioning tools together.

## NPM Script Search Path

npm looks first in the node_modules directory for the tool. Then it looks in the global installs before falling back to the path.

In order to require that only the tools specified as part of the package be run it's important to use the specific path `./node_modules/.bin` https://github.com/npm/cli/issues/2638

Benefits:

- A fixed tool version allows everyone to use the same version of the tool.
- Automation workflows only node needs to be installed (comes with npm) and only npm ci needs to be run before the `npm run <script>` commands ave available to use.
- Avoids cluttering the global namespace with tools.
- Ensures that the same tool version is run for everyone across environments.

## Windows cmd search path

Windows cmd does not need the extension on the tool to work. `cmd.exe` has a precedence list for executing items in the path without the extension's presence by looking for the command without the extension (i.e. hello will call hello.exe, hello.bat, hello.cmd, etc.. in that order as it searches the path).

## eslint disables

[eslint disabling rules](https://eslint.org/docs/user-guide/configuring/rules#disabling-rules)

```typescript

// disables for the next line
// eslint-disable-next-line no-use-before-define

// eslint-disable-line @typescript-eslint/triple-slash-reference
```

## prettier disables

[prettier ignore code](https://prettier.io/docs/en/ignore.html)

```typescript
// disables prettier for the next node
// prettier-ignore
```

## eslint rules

- https://eslint.org/docs/rules/eqeqeq
    - `==` double equals leads to bugs, double equals is usually a mistake.

## TS Doc

[@packageDocumentation](https://api-extractor.com/pages/tsdoc/tag_packagedocumentation/)
    - Document package

## Jest run single or group of tests

--testNamePattern

> npm run test -t testname*

## Technology Choice

### GitHub Actions

Make sure the operating system and the node version used in GitHub Actions matchs those used on the development machine.

### Source Control

Git is used as the source control of choice. There are many source control systems available, however the default and most ubiquitous as of 2022-03-01 is Git.

### Editor

Visual Studio Code is cross platform and is ubiquitous editor.

### TypeScript

Strong Types aid development.

An alternative to TypeScript is [JSDOC](https://jsdoc.app/) tags.


## Operating System

Ubuntu

Node currently (2022-03-01) has significantly better performance on Linux than on Windows. This results in faster job exection time, and thus reduced cost, and wait time for GitHub Action pipelines.

Ubuntu is a ubiquitous distribution and available as a build pool, and in WSL.

Commands use linux paths. On Windows WSL can be used to execute commands.

## Windows Subsystem for Linux

wls can be installed and used to run and install node.

`wsl -- <command>` executes a command in the default linux environment.

This can be used to run linux commands on Windows.

## NPM Commands

Show all published versions of a package.

> npm show @wandyezj/package@* version

## Comments on Common Packages

Generally, it's preferable to limit the number of dependencies.

### express

For simple servers express can easily be replaced with node 'http'.

Example express alternative using pure node.

```typescript
import http from "http";
import path from "path";
import * as fs from "fs";

// all valid resources stored in a resources folder.

// don't bother with express just write a simple node server.
export function startServer(port: number, serveResources: string[]) {
    const server = http.createServer((req, res) => {
        const {url} =  req;

        const found = serveResources.filter((value) => `/${value}` === url );

        if (found.length === 1) {
            const fileName = found[0];

            const filePath = path.join(__dirname + `/resources/${fileName}`);
            const fileData = fs.readFileSync(filePath)

            res.write(fileData);
        } else {
            res.write(`Not Found\n\nValid Resources:\n\n${serveResources.join("\n")}`);
        }

        res.end();
    });

    server.listen(port);

    return server;
}
```
